#!/usr/bin/env python

import xmlrpclib
import getopt
import time
import sys

import pygtk
pygtk.require('2.0')
import gtk
import gobject
import pygst
pygst.require('0.10')
import gst

KEY_EVENT_PRESS = (0)
KEY_EVENT_RELEASE = (1)

PULSE_HI = 1211
PULSE_LOW = 1183
PULSE_ARM = 1100

class ClientApp:

	def __init__(self):
		self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
		self.window.set_title("meson | storm")
		self.window.connect("destroy", self.exit)
		self.window.connect("key-press-event", self.key_event, KEY_EVENT_PRESS)
		self.window.connect("key-release-event", self.key_event, KEY_EVENT_RELEASE)
		vbox = gtk.VBox()
		self.window.add(vbox)
		self.movie_window = gtk.DrawingArea()
		vbox.add(self.movie_window)
		self.window.show_all()
		
		src = gst.element_factory_make("filesrc")
		src.set_property("location", "/home/strassek/Videos/yocto_mobile.mp4")
		dec = gst.element_factory_make("decodebin2")
		queue = gst.element_factory_make("queue")
		color = gst.element_factory_make("ffmpegcolorspace")
		sink  = gst.element_factory_make("autovideosink")

		pipeline = gst.Pipeline("pipeline")
		pipeline.add(src, dec, queue, color, sink)

		def on_pad(comp, pad, data, element):
			sinkpad = element.get_compatible_pad(pad, pad.get_caps())
			if sinkpad:
				pad.link(sinkpad)

		dec.connect("new-decoded-pad", on_pad, queue)
		src.link(dec)
		queue.link(color)
		color.link(sink)

		self.pipeline = pipeline

		bus = self.pipeline.get_bus()
		bus.add_signal_watch()
		bus.enable_sync_message_emission()
		bus.connect("sync-message::element", self.on_sync_message)

	def start_video(self):
		self.pipeline.set_state(gst.STATE_PLAYING)


	def on_sync_message(self, bus, message):
		if message.structure is None:
			return
		message_name = message.structure.get_name()
		if message_name == "prepare-xwindow-id":
			imagesink = message.src
			imagesink.set_property("force-aspect-ratio", True)
			gtk.gdk.threads_enter()
			imagesink.set_xwindow_id(self.movie_window.window.xid)
			gtk.gdk.threads_leave()

	def key_event(self, widget, event, direction):
		if direction == KEY_EVENT_PRESS:
			if event.keyval == gtk.keysyms.Escape:
				print "Good Bye.."
				self.exit()
			elif event.keyval == gtk.keysyms.w:
				print "forward"
				self.forward()
			elif event.keyval == gtk.keysyms.s:
				print "back"
				self.back()
			elif event.keyval == gtk.keysyms.a:
				print "left"
				self.left()
			elif event.keyval == gtk.keysyms.d:
				print "right"
				self.right()
			elif event.keyval == gtk.keysyms._1:
				print "Arming channel 1, please wait..."
				self.arm(1)
				time.sleep(5)
			elif event.keyval == gtk.keysyms._2:
				print "Arming channel 2, please wait..."
				self.arm(2)
				time.sleep(5)
			elif event.keyval == gtk.keysyms._3:
				print "Arming channel 3, please wait..."
				self.arm(3)
				time.sleep(5)
		elif direction == KEY_EVENT_RELEASE:
			self.stop()
			print "stop"			
				
	def exit(self):
		self.pipeline.set_state(gst.STATE_NULL)
		gtk.main_quit()

	def main(self):
		gtk.gdk.threads_init()
		self.start_video()
		gtk.main()

class ClientProxy:
	
	def __init__(self, host):
		self.proxy = xmlrpclib.ServerProxy(host)

	def arm(self, channel):
		self.proxy.add_channel(channel)
		self.proxy.set_pulse(channel, PULSE_ARM)

	def forward(self):
		self.proxy.set_pulse(1, PULSE_HI)
		self.proxy.set_pulse(2, PULSE_LOW)

	def back(self):
		self.proxy.set_pulse(1, PULSE_LOW)
		self.proxy.set_pulse(2, PULSE_LOW)

	def left(self):
		self.proxy.set_pulse(1, PULSE_LOW)
		self.proxy.set_pulse(2, PULSE_HI)
	
	def right(self):
		self.proxy.set_pulse(1, PULSE_HI)
		self.proxy.set_pulse(2, PULSE_LOW)

	def stop(self):
		self.proxy.set_pulse(1, PULSE_LOW)
		self.proxy.set_pulse(2, PULSE_LOW)

def usage():
    print """
Usage: %s [options]
Options:
    -r, --remote <uri> - Connect to remote server
    -h, --help - This help
""" % sys.argv[0]

if __name__ == '__main__':

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'r:h', ['remote=', 'help'])
    except getopt.GetoptError, e:
        print str(e)
        usage()
        sys.exit(2)

    action = 'local'
    host = 'http://localhost:8000/'

    for o, a in opts:
        if o in ('-h', '--help'):
            usage()
            sys.exit(0)
        elif o in ('-r', '--remote'):
            action = 'remote'
            host = a

    proxy = ClientProxy(host)
    app = ClientApp()

    app.forward = proxy.forward
    app.back = proxy.back
    app.left = proxy.left
    app.right = proxy.right
    app.stop = proxy.stop
    app.arm = proxy.arm

    app.main()

