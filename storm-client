#!/usr/bin/env python

import xmlrpclib
import getopt
import time
import sys

import pygtk
pygtk.require('2.0')
import gtk
import gobject
import pygst
pygst.require('0.10')
import gst

import socket

KEY_EVENT_PRESS = (0)
KEY_EVENT_RELEASE = (1)

PULSE_HI = 1211
PULSE_LOW = 1183
PULSE_ARM = 1100

class ClientApp:

    def __init__(self):
        window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        window.set_title("meson | storm")
        window.connect("destroy", gtk.main_quit, "WM destroy")
        window.connect("key-press-event", self.key_event, KEY_EVENT_PRESS)
        window.connect("key-release-event", self.key_event, KEY_EVENT_RELEASE)
        vbox = gtk.VBox()
        window.add(vbox)
        self.movie_window = gtk.DrawingArea()
        vbox.add(self.movie_window)
        window.show_all()
        
        src = gst.element_factory_make("filesrc", "file-source")
        src.set_property("location", "/home/strassek/Videos/yocto_mobile.mp4")
        dec = gst.element_factory_make("decodebin2", "decoder")
        sink  = gst.element_factory_make("autovideosink", "sink")

        self.fakev = sink

        pipeline = gst.Pipeline("pipeline")
        pipeline.add(src, dec, sink)
        
        dec.connect("new-decoded-pad", self.decoder_callback)
        gst.element_link_many(src, dec)

        bus = pipeline.get_bus()
        bus.add_signal_watch()
        bus.enable_sync_message_emission()
        bus.connect("sync-message::element", self.on_sync_message)
        bus.connect("message", self.on_message)

        self.window = window
        self.pipeline = pipeline

    def on_sync_message(self, bus, message):
        if message.structure is None:
            return
        message_name = message.structure.get_name()
        if message_name == "prepare-xwindow-id":
            imagesink = message.src
            imagesink.set_property("force-aspect-ratio", True)
            gtk.gdk.threads_enter()
            imagesink.set_xwindow_id(self.movie_window.window.xid)
            gtk.gdk.threads_leave()

    def on_message(self, bus, message):
        t = message.type
        if t == gst.MESSAGE_STATE_CHANGED:
            if message.parse_state_changed()[1] == gst.STATE_PAUSED:
                for i in self.pipeline.get_by_name("decoder").src_pads():
                    structure_name = i.get_caps()[0].get_name()
                    if structure_name.startswith("video") and "width" in i.get_caps()[0].keys():
                        if len(str(i.get_caps()[0]["width"])) < 6:
                            w = i.get_caps()[0]["width"]
                            h = i.get_caps()[0]["height"]
                            self.window.resize(width=w, height=h)
                            break
        elif t == gst.MESSAGE_ERROR:
            err, debug = message.parse_error()
            print "Error: %s" % err, debug
            self.pipeline.set_state(gst.STATE_NULL)

    def decoder_callback(self, decoder, pad, data):
        structure_name = pad.get_caps()[0].get_name()
        if structure_name.startswith("video"):
            fv_pad = self.fakev.get_pad("sink")
            pad.link(fv_pad)

    def key_event(self, widget, event, direction):
        if direction == KEY_EVENT_PRESS:
            if event.keyval == gtk.keysyms.Escape:
                gtk.main_quit()
            elif event.keyval == gtk.keysyms.p:
                if self.pipeline.get_state()[1] == gst.STATE_PLAYING:
                    self.pipeline.set_state(gst.STATE_PAUSED)
                else:
                    self.pipeline.set_state(gst.STATE_PLAYING)
            elif event.keyval == gtk.keysyms.w:
                print "forward"
                self.forward()
            elif event.keyval == gtk.keysyms.s:
                print "back"
                self.back()
            elif event.keyval == gtk.keysyms.a:
                print "left"
                self.left()
            elif event.keyval == gtk.keysyms.d:
                print "right"
                self.right()
            elif event.keyval == gtk.keysyms._1:
                print "Arming channel 1, please wait..."
                self.arm(1)
            elif event.keyval == gtk.keysyms._2:
                print "Arming channel 2, please wait..."
                self.arm(2)
            elif event.keyval == gtk.keysyms._3:
                print "Arming channel 3, please wait..."
                self.arm(3)
            elif direction == KEY_EVENT_RELEASE:
                print "stop"            
                self.stop()

    def main(self):
        gtk.gdk.threads_init()
        self.pipeline.set_state(gst.STATE_PLAYING)
        gtk.main()

class ProxyHandler:
    
    def __init__(self, host):
        self.proxy = xmlrpclib.ServerProxy(host)
        #TODO ping host and do not allow further action until connected

    def send_pulse(self, channel, pulse):
        try:
            self.proxy.set_pulse(channel, pulse)
        except xmlrpclib.Fault, err:
            print "[xmlrpc fault (%d)] %s" % (err.faultCode, err.faultString)
        except socket.error, err:
            print "[socket error] %s" % err

    def arm(self, channel):
        self.proxy.add_channel(channel)
        self.send_pulse(channel, PULSE_ARM)

    def forward(self):
        self.send_pulse(1, PULSE_HI)
        self.send_pulse(2, PULSE_LOW)

    def back(self):
        self.send_pulse(1, PULSE_LOW)
        self.send_pulse(2, PULSE_LOW)

    def left(self):
        self.send_pulse(1, PULSE_LOW)
        self.send_pulse(2, PULSE_HI)
    
    def right(self):
        self.send_pulse(1, PULSE_HI)
        self.send_pulse(2, PULSE_LOW)

    def stop(self):
        self.send_pulse(1, PULSE_LOW)
        self.send_pulse(2, PULSE_LOW)

def usage():
    print """
Usage: %s [options]
Options:
    -r, --remote <uri> - Connect to remote server
    -h, --help - This help
""" % sys.argv[0]

if __name__ == '__main__':

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'r:h', ['remote=', 'help'])
    except getopt.GetoptError, e:
        print str(e)
        usage()
        sys.exit(2)

    action = 'local'
    host = 'http://localhost:8000/'

    for o, a in opts:
        if o in ('-h', '--help'):
            usage()
            sys.exit(0)
        elif o in ('-r', '--remote'):
            action = 'remote'
            host = a

    proxy = ProxyHandler(host)
    app = ClientApp()

    app.forward = proxy.forward
    app.back = proxy.back
    app.left = proxy.left
    app.right = proxy.right
    app.stop = proxy.stop
    app.arm = proxy.arm

    app.main()

